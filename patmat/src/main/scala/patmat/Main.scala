package patmat
import Huffman._

object Main extends App {
    println(times(List('a', 'b', 'c')))
    println(times(List('a', 'b', 'a')))
    println(times(List('a', 'b', 'a', 'b', 'a', 'a', 'x', 'a')))
    println(times(List('a', 'b', 'a', 'b', 'a', 'a', 'x', 'a')))
    println(times(List('a')))
    println(makeOrderedLeafList(times(List('a', 'b', 'a', 'b', 'a', 'a', 'x', 'a'))))
    println(1 :: Nil)
    println(singleton(List(Leaf('a', 2))))
    println(singleton(Leaf('a', 2) :: Nil))
    println(singleton(Leaf('a', 2) :: List(Leaf('b', 3))))
    println(singleton(List()))
    println(combine(List(Leaf('a',2), Leaf('b', 3), Leaf('c', 4))))
    println(combine(List(Leaf('a',1), Leaf('b', 2), Leaf('c', 4))))
    println(until(singleton, combine)(List(Leaf('a',2), Leaf('b', 3), Leaf('c', 4))))
    println(until(singleton, combine)(List(Leaf('a',1), Leaf('b', 2), Leaf('c', 4))))
    println(createCodeTree("abbcccc".toList))
    println(createCodeTree("cabcabcbc".toList))
    val codeTree = createCodeTree("abbcccc".toList)
    println(decode(codeTree, List(0,0,0,1,0,1,1,1,1,1)))
    println(decode(frenchCode, secret))
    println(decodedSecret)
    // println(List(1,2,3).contains(2))
    println(1 :: (2 :: 3 :: Nil))
    println(encode(codeTree)("abbcccc".toList))
    println(quickEncode(codeTree)("abbcccc".toList))
    println(List(1) ::: Nil)
    println(List(('a', 1)) == List(('a', 1)))
    println(List(('a', 1)) contains List(('a', 1)))
    println(convert(codeTree))
}